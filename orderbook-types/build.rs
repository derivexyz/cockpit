/*
Builds .rs schema files for every .json schema in the schemas directory
Since API does not update very often, this only needs to be ran after major API changes,
and can be left commented out otherwise.
JSON schemas must be generated by the export_api.py script of the orderbook repo.
*/

use regex::Regex;
use schemars::schema::{InstanceType, SchemaObject};
use std::{fs, path::Path};
use typify::{TypeSpace, TypeSpaceSettings};

fn main() {
    return;
    // find all json files in the schemas directory
    let target_folder_name = "./src/types";
    // delete all files from target_folder
    let target_folder = Path::new(target_folder_name);
    for entry in fs::read_dir(target_folder).unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();
        if path.is_file() {
            fs::remove_file(path).expect("remove_file");
        }
    }
    let schemas = fs::read_dir("./schemas").expect("fs::read_dir");
    // iterate over the files
    for schema in schemas {
        let schema = schema.unwrap();
        let path = schema.path();
        let file_name = path
            .file_name()
            .expect("file_name")
            .to_str()
            .expect("to_str");
        println!("Processing: {}", file_name);
        let ext = path
            .extension()
            .unwrap_or_default()
            .to_str()
            .unwrap_or_default();
        if ext != "json" {
            continue;
        }
        let content = fs::read_to_string(&path).expect("read_to_string");
        let content = content.replace("anyOf", "oneOf");
        // some fields have an "enum": ["ok"] element that breaks the build
        // want to replace it with "const": "ok"
        let re = Regex::new(r#""enum"\s*:\s*\[\s*"ok"\s*\]"#).expect("Invalid regex");
        let content = re.replace_all(&content, r#""const": "ok""#);
        // replace ' "default": null, ' strings with empty string - not supported by typify
        let re = Regex::new(r#""default":\s*null,"#).expect("Invalid regex");
        let content = re.replace_all(&content, r#""#);
        let schema = serde_json::from_str::<schemars::schema::RootSchema>(&content)
            .expect("serde_json::from_str");

        // create a new type space
        let mut type_space = TypeSpace::new(
            TypeSpaceSettings::default()
                .with_struct_builder(false)
                .with_conversion(
                    SchemaObject {
                        instance_type: Some(InstanceType::String.into()),
                        format: Some("decimal".to_string()),
                        ..Default::default()
                    },
                    "bigdecimal::BigDecimal",
                    [].into_iter(),
                ),
        );
        match type_space.add_root_schema(schema) {
            Ok(_) => {}
            Err(e) => {
                println!("Error: {}", e);
                continue;
            }
        }

        // generate the types
        let contents = format!(
            "{}\n{}\n{}\n{}\n{}",
            "#![allow(unused_variables)]\n#![allow(unused_imports)]",
            "use serde::{Deserialize, Serialize};",
            "use bigdecimal;",
            "use uuid;",
            prettyplease::unparse(
                &syn::parse2::<syn::File>(type_space.to_stream()).expect("unparse")
            )
        );
        // don't want to deny unknown fields in case API adds a new one
        let contents = contents.replace("#[serde(deny_unknown_fields)]", "");

        // write the types to a file
        let mut out_file = Path::new(target_folder_name).to_path_buf();
        // replace private., public. and channel. with _ instead of .
        let file_name = file_name.replace(".", "_");
        let file_name = file_name.replace("_json", ".rs");
        out_file.push(file_name);
        fs::write(out_file, contents).expect("fs:write");
    }
}
